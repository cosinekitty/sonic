<html>

<head>
<title>The Sonic Programming Language: A User Manual</title>
</head>

<body bgcolor="lightcyan">
<h2 align="center">The Sonic Programming Language: A User Manual</h2>
<h3 align="center">by 
<a href="http://cosinekitty.com">Don Cross</a> - 
<a href="mailto:cosinekitty@gmail.com">cosinekitty@gmail.com</a></h3>
<p align="center"><font face="Arial">This manual was last updated on 10 November 1998.</font></p>
<p>
<hr>

<h2>Table of Contents</h2>
<ul>
	<li><a href="#about">About This Manual</a></li>
	<li><a href="#purpose">Purpose of the Sonic Language</a></li>

	<li><a href="#syntax">Sonic Syntax</a></li>
	<ul>
		<li><a href="#syntax_sample">A Sample Program</a></li>
		<li><a href="#syntax_type">Data Types</a></li>
		<li><a href="#syntax_array">Arrays</a></li>		
		<li><a href="#syntax_constant">Built-In Constants</a></li>
		<li><a href="#syntax_function">Functions</a></li>
		<ul>
			<li><a href="#syntax_function_user">User-Defined Functions</a></li>
			<li><a href="#syntax_function_intrinsic">Intrinsic Functions</a></li>
			<li><a href="#syntax_function_pseudo">Pseudo-functions</a></li>
			<ul>
				<li><a href="#pseudofunc_sinewave">sinewave</a></li>
				<li><a href="#pseudofunc_sawtooth">sawtooth</a></li>
				<li><a href="#pseudofunc_iir">iir</a></li>
				<li><a href="#pseudofunc_fft">fft</a></li>
			</ul>
			<li><a href="#syntax_function_import">Import Functions</a></li>
		</ul>

		<li><a href="#syntax_var">Variable Declarations</a></li>

		<li><a href="#syntax_statement">Statements</a></li>
		<ul>
			<li><a href="#syntax_assignment_operator">Assignment Operators</a></li>
			<li><a href="#syntax_statement_simple_assignment">Simple Assignment Statements</a></li>

			<li><a href="#syntax_statement_wave_assignment">Wave Assignment Statements</a></li>
			<ul>
				<li><a href="#wassign_channel_placeholder">Channel Placeholder 'c'</a></li>
				<li><a href="#wassign_index_placeholder">Index Placeholder 'i'</a></li>
				<li><a href="#wassign_rt_placeholder">Rate 'r' and Time 't' Placeholders</a></li>
				<li><a href="#wassign_operators">Wave Assignment Operators</a></li>
				<li><a href="#wassign_old_data">Old Data Placeholder '$'</a></li>
				<li><a href="#wassign_append">Append Operator '&lt;&lt;'</a></li>
				<li><a href="#wassign_vector">Vector Expressions</a></li>
			</ul>

			<li><a href="#syntax_statement_if">if / else Statements</a></li>
			<li><a href="#syntax_statement_while">while Statements</a></li>
			<li><a href="#syntax_statement_for">for Statements</a></li>
			<li><a href="#syntax_statement_repeat">repeat Statements</a></li>
			<li><a href="#syntax_statement_return">return Statements</a></li>
			<li><a href="#syntax_statement_function_call">Function Calls</a></li>
		</ul>

		<li><a href="#syntax_expression">Expressions and Operators</a></li>
		<li><a href="#syntax_comment">Comments</a></li>
		<li><a href="#syntax_bnf">Extended Backus-Naur Form Syntax of Sonic</a></li>		
	</ul>

<!--
	<li><a href="#sound_format">Audio File Formats</a></li>
-->

	<li><a href="#translator">How to Use the Sonic/C++ Translator</a></li>
</ul>

<!-- ======================================================================== -->
<p>
<hr>
<a name="about"></a>
<h2>About This Manual</h2>
This user manual is for the Sonic programming language, version 0.907.
<p>
This HTML-format reference manual may be freely distributed to third parties so long as it is not altered in any way.  Feel free to save a copy to your own hard drive for convenient reference.
<p>
Please address all comments, questions, or suggestions about this manual or the Sonic language to Don Cross by email at:<br>
<a href="cosinekitty@gmail.com">cosinekitty@gmail.com</a>
</a>

<!-- ======================================================================== -->
<p>
<hr>
<a name="purpose"></a>
<h2>Purpose of the Sonic Language</h2>
Sonic is a programming language for writing concise programs to perform useful digital audio operations, including synthesis of new sounds and processing of existing sounds.  The emphasis of Sonic is to allow for a reasonable amount of runtime efficiency, while maximizing the convenience of experimenting and trying out ideas.  Because Sonic  generates C++ target code, it allows a programmer to develop algorithms that easily port to a variety of hardware platforms and operating systems.

<!-- ======================================================================== -->
<p>
<hr>
<a name="syntax"></a>
<h2>Sonic Syntax</h2>
Sonic is a structured imperative language, similar in spirit to languages like C and Pascal.  The language features familiar constructs such as <tt>while</tt> and <tt>for</tt> loops, <tt>if / else</tt> statements, arrays, and local variables.
<p>
All Sonic programs are command-line based utilities.  They are told what to do using audio filenames and numeric parameters passed on the command line.
<p>
A Sonic program consists of <a href="#syntax_function">functions</a> that contain <a href="#syntax_var">variable declarations</a> and <a href="#syntax_statement">statements</a>.  Functions may call other functions or themselves.  Optionally, functions may <a href="#syntax_statement_return">return values</a>.

<!-- ======================================================================== -->

<a name="syntax_sample"></a>
<h3>A Sample Program</h3>
Instead of starting with abstractions and theory, let's start with a useful sample program written in Sonic.  The following program reads an input sound and adds an echo effect to yield an output sound.
<p>
<blockquote><pre>
// This Sonic program makes echo sounds!

program reverb (
    inWave: wave,
    outWave: wave,
    delayTime: real,
    decayFactor: real,
    extendTime: real )
{
    outWave[c, i: inWave.n + r*extendTime] =
        inWave[c,i] +
        decayFactor * outWave[c, i - r*delayTime];
}    
</pre></blockquote>
<p>
All Sonic programs are command line utilities.  They accept arguments such as audio filenames and numeric values on the command line.  These arguments are listed inside parentheses after the keyword '<tt>program</tt>' and the name of the program.  The sample program here requires 5 arguments: an input audio filename, an output audio filename, a delay time expressed in seconds, a numeric decay factor, and an amount of time by which the output should be longer than the input.
<p>
To run the above Sonic program, you would need to use a text editor to type it into a file (perhaps called '<tt>reverb.s</tt>') and run the Sonic/C++ translator on it:
<blockquote><pre>
sonic reverb.s
</pre></blockquote>
This would result in the output C++ source file called '<tt>reverb.cpp</tt>'.  Note that the output filename is derived directly from the name after the keyword '<tt>program</tt>', not the name of the source file.
<p>
<strong>The most important feature of Sonic is that digital audio operations are performed by parametric assignment statements.</strong>  This means that the output sound is described in terms of a typical output data value, identified by its channel '<tt>c</tt>' and its sample index '<tt>i</tt>'.  The reserved symbols '<tt>c</tt>' and '<tt>i</tt>' are called <i>placeholders</i>.  There is no need for an explicit loop to iterate through the samples and channels; this is implicit in the language.
<p>
The variable name appearing on the left side of the equal sign specifies where the output audio is stored.  The expression appearing after '<tt>i:</tt>' defines the number of samples that will be in the output sound.  In certain circumstances it is possible to omit this duration specifier, as described in the 
<a href="#syntax_statement_wave_assignment">section about wave assignments</a>.
<p>
On the right side of the equal sign is an expression in terms of <tt>c</tt> and <tt>i</tt>.  This expression defines each output data value in terms of its channel number and sample index.  The sample program here adds the current input value from '<tt>inWave</tt>' to a decayed previous output from '<tt>outWave</tt>'.  Note that Sonic allows the use of a mathematical recurrence relation in its wave assignments, so that previous outputs can be used to help calculate future outputs.  For convenience, when the sample index is out of bounds, the value of a sound is defined to be zero.  Therefore, there is no need to worry about array bounds checking in the sample index.  The same is not true of the channel index, because such behavior would not be nearly as useful and would degrade runtime performance.  Therefore, it is up to the programmer to ensure that the channel index is always valid.  An out-of-bounds channel index produces undefined results, just as with array indices in C or C++.
<p>
Note that there is no need to explicitly open, read, write, and close files in Sonic.  All of these low-level operations are handled automatically.  This sample program knows to open <tt>outWave</tt> for write and <tt>inWave</tt> for read simply by where they appear in the assignment statement.  Files are opened before the beginning of each assignment statement, and are closed after the assignment is executed.

<!-- ======================================================================== -->

<hr>
<a name="syntax_type"></a>
<h3>Data Types</h3>
The following data types exist in Sonic.  Note that, except for the type <tt>wave</tt> and 
<a href="#syntax_function_import">import function types</a>, 
all of these types depend on the data types as implemented by the C++ compiler you use.  If users so desire, I may change this in the future so that the programmer has more control over the actual data types.
<ul>
	<li><b><tt>integer</tt></b> - a signed integer number, same as type <tt>long</tt> in your C++ compiler.</li>
	<li><b><tt>real</tt></b> - a signed double-precision floating point number, same as type <tt>double</tt> in your C++ compiler.</li>
	<li><b><tt>boolean</tt></b> - a true/false value, implemented using the <tt>int</tt> type on your C++ compiler.  [I don't use the C++ type <tt>bool</tt> because many older compilers don't have it.]  A variable of this type may have one of two possible values: <tt>true</tt> or <tt>false</tt>.  The symbols <tt>true</tt> and <tt>false</tt> are reserved in Sonic.</li>
	<li><b><tt>wave</tt></b> - represents a digital audio file.  See the class '<tt>SonicWave</tt>' in the Sonic runtime library file '<tt>sonic.h</tt>'.</li>
	<li><a href="#syntax_function_import">import function types</a> - allow user-defined C++ classes to be imported into a Sonic program.</li>
	<li><b>arrays</b> - Sonic allows arrays of <tt>boolean</tt>, <tt>integer</tt>, and <tt>real</tt>.  Arrays may have one or more dimensions.  See the 
<a href="#syntax_array">section on arrays</a> for more information.</li>
</ul>

<!-- ======================================================================== -->

<hr>
<a name="syntax_array"></a>
<h3>Arrays</h3>
Sonic allows variables and function parameters to be arrays of the simple types <tt>boolean</tt>, <tt>integer</tt>, and <tt>real</tt>.  Arrays of other types are not allowed.  To declare an array variable, follow one of these simple types by a list of one or more comma-delimited integer constants enclosed in square brackets.  Here is an example of a variable that is a three-dimensional array of real numbers:
<blockquote><pre>
var  umbrella: real[5, 3, 8];
</pre></blockquote>
As in C and C++, all array indices are zero-based.  For example, in the array declaration above, <tt>umbrella[0,0,0]</tt> is the first array element, and <tt>umbrella[4,2,7]</tt> is the last array element.  Such a subscripted array expression may appear anywhere a variable may appear, whether in an expression, function call, or left side of an assignment operator.
<p>
A non-subscripted array variable may appear on the left side of an assignment statement only when another non-subscripted array variable of identical type appears to the right of the assignment operator.  For example:
<blockquote><pre>
var x: real[5];
var y: real[5];
var z: real[7];
x += y;    // add each element of 'y' to corresponding element of 'x'.
z = x;     // ERROR!  don't have same number of elements.
</pre></blockquote>
Arrays may be passed to any non-program function.  All arrays are passed by reference.  The element type of the passed array must be identical to the declared element type in the function parameter list.  All dimensions must match except for the first dimension in the function parameter list, which is ignored, just as in C and C++.  Also, like C and C++, no array bounds checking is ever performed.  It is up to the programmer to ensure that subscripts to arrays are within the valid range of values for each dimension.
<p>
Array variables with numeric element types are initialized to all zeroes, and arrays of <tt>boolean</tt> are initialized to all <tt>false</tt> values.  Array variables are not allowed to have explicit initializer expressions.

<!-- ======================================================================== -->

<hr>
<a name="syntax_constant"></a>
<h3>Built-In Constants</h3>
Sonic provides certain symbols that have pre-defined constant values, called <i>built-in constants</i>.  Some built-in constants may have their default values redefined by the programmer, though they are still constants because their value remains fixed for the entire program.  Other built-in constants always retain their pre-defined values.
<p>
Here is a list of the built-in constants whose default values may be overridden:
<blockquote>
<tt><b>r</b> = </tt>sampling rate expressed in Hz.  [defaults is 44100]<p>
<tt><b>m</b> = </tt>number of channels.  [defaults to 2, but may be 1..64]<p>
<tt><b>interpolate</b> = true/false</tt>; whether to linearly interpolate between samples [default = <tt>true</tt>].<br>
When set to <tt>true</tt>, the Sonic/C++ translator will check the index parameter for being a non-integer (i.e. real) value.  If the index is not an integer, the generated C++ code will call <tt>SonicWave::interp()</tt> instead of <tt>SonicWave::fetch()</tt>.  This results in much cleaner sound than when <tt>interpolate</tt> is set to <tt>false</tt>, but it will execute somewhat slower.  However, even if <tt>interpolate</tt> is <tt>true</tt>, the translator knows to still call <tt>SonicWave::fetch()</tt> if the index expression is of integer type, so that the code is faster and still produces the same effect.  Therefore, it is recommended that you leave <tt>interpolate</tt> to its default value of <tt>true</tt>.
</blockquote>
To redefine one of these built-in constants, just use the syntax <tt><i>constant</i> = <i>value</i>;</tt>.  Statements like this must appear outside a 
<a href="#syntax_function_user">user-defined function</a>.  Here is a sample program that generates an output audio recording with 1 channel at a sampling rate of 8000 Hz.  It also explicitly sets the <tt>interpolate</tt> flag, even though <tt>true</tt> is the default value anyway.
<blockquote><pre>
m = 1;
r = 8000;
interpolate = true;

program tone ( output: wave )
{
    output[c,i:5*r] = sinewave(1,300,0);
}
</pre></blockquote>

Here is a list of the built-in constants that cannot be re-defined:
<blockquote>
<tt><b>true</b> = </tt>the boolean affirmative value<br>
<tt><b>false</b> = </tt>the boolean negative value<br>
<tt><b>pi</b> = </tt>the ratio of a circle's circumference to its diameter, 3.141592...<br>
<tt><b>e</b> = </tt>the base of natural logarithms, 2.7182818...
</blockquote>

<!-- ======================================================================== -->

<hr>
<a name="syntax_function"></a>
<h3>Functions</h3>
There are four kinds of functions in Sonic: 
<a href="#syntax_function_user">user-defined functions</a>,
<a href="#syntax_function_intrinsic">intrinsic functions</a>,
<a href="#syntax_function_pseudo">pseudo-functions</a>, and
<a href="#syntax_function_import">import functions</a>.

<a name="syntax_function_user"></a>
<h4>User-Defined Functions</h4>
User-defined functions are functions that are coded using Sonic syntax inside a Sonic program.  There are two kinds of user-defined functions: <i>program functions</i> and <i>non-program functions</i>.  Both kinds of user-defined functions accept zero or more arguments, have zero or more local variables, and contain zero or more executable <a href="#syntax_statement">statements</a>.  The differences between program functions and non-program functions are:
<ul>
	<li>Program functions begin with the keyword '<tt>program</tt>', whereas non-program functions begin with the keyword '<tt>function</tt>'.</li>
	<li>Non-program functions may optionally return a value.  Program functions never return a value.</li>
	<li>Exactly one program function appears in every valid Sonic program, but Sonic allows any number of non-program functions.</li>
	<li>The required program function identifies where execution begins in Sonic, just like <tt>main()</tt> does in a C++ program.  The command line parameters used to run the Sonic program are mapped onto the program function's formal arguments.
</ul>
Either kind of user-defined function may call any other user-defined function.  Also, either kind may call itself recursively.  Here is a small sample program that generates a 1-second frequency modulated tone:
<blockquote><pre>
r = 22050;   // set sampling rate to 22050 Hz

program fmsynth ( outWave:wave, freq:real )
{
    outWave[c,i:r] = fm ( 5, freq, t );
}

function fm ( depth:integer, freq:real, time:real ): real
{
    if ( depth &lt; 1 )
        return sin(2*pi*freq*time);

    return sin ( depth*pi*freq*time + fm(depth-1,freq,time) );
}
</pre></blockquote>
Functions may appear in any order.  Note that the program function '<tt>fmsynth</tt>' calls the non-program function '<tt>fm</tt>', even though '<tt>fm</tt>' is defined later in the source code.
<p>
The function '<tt>fm</tt>' returns a real value, indicated by the '<tt>: real</tt>' appearing after the closing parenthesis of the argument list.  Functions that do not return a value simply omit the '<tt>:</tt>' and the return type.
<p>
Functions may accept arguments of any type, but they may not return values of type <tt>wave</tt>.  By default, parameters to a user-defined function are passed by value, except for <tt>wave</tt> arguments and <a href="#syntax_function_import">import function object</a> arguments, which are passed by reference.  To force a parameter to be passed by reference, add an ampersand '<tt>&amp;</tt>' after the formal parameter's type.  When you call a function that accepts parameters by reference, those parameters must be variable names.  Here is an example of a function that accepts two real parameters by reference so that it can swap their values and have the change persist in the calling code.
<blockquote><pre>
function swap ( x: real&amp;, y: real&amp; )
{
    var temp=x: real;
    x = y;
    y = temp;
}
</pre></blockquote>

<a name="syntax_function_intrinsic"></a>
<h4>Intrinsic Functions</h4>
Simple numeric functions that are built into the Sonic language are called <i>intrinsic functions</i>.  Currently, all intrinsic functions accept one or more arguments of type <tt>real</tt> and return a <tt>real</tt> value.  Here is a list of the intrinsic functions currently supported by Sonic.
<ul>
	<li><tt>sin(x)</tt> = the sine of <tt>x</tt> radians.</li>
	<li><tt>cos(x)</tt> = the cosine of <tt>x</tt> radians.</li>
	<li><tt>tan(x)</tt> = the tangent of <tt>x</tt> radians.</li>
	<li><tt>sinh(x)</tt> = the hyperbolic sine of <tt>x</tt>.</li>
	<li><tt>cosh(x)</tt> = the hyperbolic cosine of <tt>x</tt>.</li>
	<li><tt>tanh(x)</tt> = the hyperbolic tangent of <tt>x</tt>.</li>
	<li><tt>asin(x)</tt> = the inverse sine of <tt>x</tt>.</li>
	<li><tt>acos(x)</tt> = the inverse cosine of <tt>x</tt>.</li>
	<li><tt>atan(x)</tt> = the inverse tangent of <tt>x</tt>.</li>
	<li><tt>atan2(y,x)</tt> = the inverse tangent of <tt>y/x</tt>.  (Returns angle that reflects <tt>x</tt> and <tt>y</tt> from any quadrant.)</li>
	<li><tt>abs(x)</tt> = the absolute value of <tt>x</tt>.</li>
	<li><tt>ceil(x)</tt> = the smallest integer greater than or equal to <tt>x</tt>.
	<li><tt>floor(x)</tt> = the largest integer less than or equal to <tt>x</tt>.
	<li><tt>sqrt(x)</tt> = the square root of <tt>x</tt>.</li>
	<li><tt>square(x)</tt> = <tt>x*x</tt>.</li>
	<li><tt>cube(x)</tt> = <tt>x*x*x</tt>.</li>
	<li><tt>quart(x)</tt> = <tt>x*x*x*x</tt>.</li>
	<li><tt>recip(x)</tt> = <tt>1/x</tt>.</li>
	<li><tt>hypot(x,y)</tt> = the distance from the origin to the point (x,y) on the cartesian plane.</li>
	<li><tt>ln(x)</tt> = the natural logarithm of <tt>x</tt>.</li>
	<li><tt>log(x)</tt> = the base-10 logarithm of <tt>x</tt>.</li>
	<li><tt>exp(x)</tt> = <tt>e</tt> raised to the <tt>x</tt> power.</li>
	<li><tt>dB(x)</tt> = <tt>x</tt> decibels converted to a scalar constant; same as <tt>10^(x/20)</tt>.</li>
	<li><tt>noise(x)</tt> = a random number in the range (-x,x).</li>
</ul>

<a name="syntax_function_pseudo"></a>
<h4>Pseudo-Functions</h4>
For convenience and runtime performance, Sonic has certain constructs that look like functions, but differ from true functions in critical ways.  These constructs are not true functions because they may appear only in a 
<a href="#syntax_statement_wave_assignment">wave assignment</a>, 
and their values are not completely determined by their arguments.  Such constructs are called <i>pseudo-functions</i>.  Currently, the following pseudo-functions exist:

<p>
<a name="pseudofunc_sinewave"></a>
<b><tt>sinewave(A,F,P)</tt></b> = a sinewave with amplitude <tt>A</tt>, frequency <tt>F</tt> Hz, and phase <tt>P</tt> degrees.  For example, the 
<a href="#syntax_statement_wave_assignment">wave assignment</a>
<blockquote><pre>
outWave[c,i:5*r] = sinewave(1,440,90);
</pre></blockquote>
generates a five-second 440 Hz cosine wave of unit amplitude.  The arguments to the <tt>sinewave</tt> pseudo-function are evaluated once before the enclosing wave assignment is executed.  Note that it is highly recommended that you use the <tt>sinewave</tt> pseudo-function instead of the 
<a href="#syntax_function_intrinsic">intrinsic function</a>
<tt>sin(x)</tt> wherever possible, because it is extremely fast in comparison.  The <tt>sinewave</tt> pseudo-function is implemented in terms of trigonometric recurrence relations that require only one multiplication, one subtraction, and two floating point assignments per sample iteration.  However, you still will need to use intrinsic functions like <tt>sin(x)</tt> or <tt>cos(x)</tt> whenever the argument <tt>x</tt> is not a linear function of <tt>i</tt>.

<p>
<a name="pseudofunc_sawtooth"></a>
<b><tt>sawtooth(F)</tt></b> = a sawtooth (triangular) wave with frequency <tt>F</tt> Hz, having the range [-1,1].

<p>
<a name="pseudofunc_iir"></a>
<b><tt>iir ( {<i>x_coeff_list</i>}, {<i>y_coeff_list</i>}, <i>expression</i> )</tt></b> = infinite impulse response (IIR) filter of the given <tt><i>expression</i></tt>, using the given list of x-coefficients and y-coefficients.  For example, the wave assignment
<blockquote><pre>
y[c,i] = iir ( {0.3, 0.4}, {-0.1}, x[c,i] );
</pre></blockquote>
is equivalent to
<blockquote><pre>
y[c,i] = 0.3*x[c,i] + 0.4*x[c,i-1] - 0.1*y[c,i-1];
</pre></blockquote>
Note that the x-coefficient list must contain at least one expression, whereas the y-coefficient list may contain zero or more expressions.  If the y-coefficient list is empty, the resulting filter is actually a finite impulse response (FIR) filter.  The <tt><i>expression</i></tt> may be a function of <tt>c</tt> and <tt>i</tt>, but the x- and y-coefficient lists of expressions must not.  The coefficent list expressions are evaluated once before the enclosing assignment statement is executed.  The programmer may nest <tt>iir</tt> constructs to implement cascaded filters.

<p>
<a name="pseudofunc_fft"></a>
<b><tt>fft ( <i>expression</i>, <i>fft_size</i>, <i>transfer_func</i>, <i>freq_shift</i> )</tt></b><br>
Filters <tt><i>expression</i></tt> using the 
Fast Fourier Transform
(FFT) algorithm.  The input <tt><i>expression</i></tt> is split up into buffers defined by <tt><i>fft_size</i></tt>.  Each buffer is fed through the FFT and the resulting frequency spectrum is processed by the specified user-defined transfer function.  Afterward, the entire spectrum is shifted up or down depending on the value <tt><i>freq_shift</i></tt>.  Finally, the processed spectrum is fed through the inverse FFT to obtain a processed time signal.  An &quot;overlap-add&quot; technique is used to eliminate boundary discontinuities inherent in FFT processing.
<p>
Before the enclosing wave assignment is executed, the <tt><i>fft_size</i></tt> and <tt><i>freq_shift</i></tt> terms are evaluated once.
<p>
The <tt><i>fft_size</i></tt> term defines the size of the FFT buffers, and must evaluate to a positive integer power of 2 (for example, 1024 or 4096).  If a number that is not a power of 2 is encountered, a runtime error will occur.  Divide <tt><i>fft_size</i></tt> by the sampling rate to determine the time length of the FFT buffer.  For example, a FFT buffer with 4096 samples divided by a sampling rate of 44100 Hz yields an FFT buffer that is 4096/44100 = 0.0929 seconds long.  It is recommended that you make the buffer be longer than 0.05 seconds to keep buffer width distortion lower than audible 20 Hz (reciprocal of buffer length).
<p>
The <tt><i>transfer_func</i></tt> must be the name of a user-defined function with the following parameter types.  Note that the function must not return a value:
<blockquote><pre>
function xfer ( freq:real, zr:real&amp;, zi:real&amp; )
{
    // ...
}
</pre></blockquote>
This function will be called once for every positive frequency bin in the frequency spectrum.  The first parameter is the frequency of the given bin expressed in Hz.  The following two parameters are the real and imaginary components of the frequency bin.  They are passed by reference so that the function may modify their values.  For example, to eliminate a given frequency in the input signal, set <tt>zr</tt> and <tt>zi</tt> to zero when that frequency is encountered.
<p>
The <tt><i>freq_shift</i></tt> term defines the amount by which the frequency spectrum is to be shifted after being processed by the user-defined function and before being fed through the inverse transform.  This provides a simple method for pitch shifting.  This value is expressed in Hz.  If it is positive, frequencies will be shifted upward (pitch increase), and if it is negative, frequencies will be shifted downward (pitch decrease).  Set this value to zero if you don't want any pitch shifting to take place.
<p>
Note that using the FFT filter will result in a signal delay equal to a full buffer width.  Therefore, you may need to pad the output signal by <tt><i>fft_size</i></tt> samples to get the entire filtered signal.

<a name="syntax_function_import"></a>
<h4>Import Functions</h4>
Sonic allows the programmer to write C++ classes and import them into Sonic programs.  Such classes must overload <tt>operator()</tt> so that objects of that class type can act as functions in an expression.  The functions may accept any number of arguments of any type, including <tt>wave</tt>.
<p>
There are two constraints to a C++ class that implements an import function type.  First, if it is to be used inside a wave assignment, the class must implement the following member function:
<blockquote><pre>
void reset ( int numChannels, long samplingRate );
</blockquote></pre>
A variable of an import function type will receive a call to this member function immediately before Sonic executes any wave assignment in which that variable appears.  Only one call will be made to this member function for each import function variable  in the wave assignment, even if the import function variable appears more than once.
<p>
The second constraint is that the import function class must have a name beginning with '<tt>i_</tt>' followed by at least one more character.
<p>
Here is an example of a valid C++ declaration for an import function type:
<blockquote><pre>
// happy.h
class i_Happy
{
    i_Happy ( double freq );     // constructor may have any number of arguments
    double operator() ( int c, long i, double z );     // same here
    double operator() ( int c, long i );      // may overload for different arg count
    void reset ( int numChannels, long samplingRate );
};
</blockquote></pre>
Here is an example of how you would use the above import function type in a Sonic program:
<blockquote><pre>
import Happy from &quot;happy.h&quot;;   // note class name here omits the 'i_'

program JoyJoy ( outWave: wave )
{
    var stimpy(220), ren(440): Happy;
    outWave[c,i:3*r] = stimpy(c,i,5) - ren(c,i);
}
</pre></blockquote>
Another example of how to create an import function has been provided in the Sonic runtime library.  See the files '<tt>pluck.h</tt>' and '<tt>pluck.cpp</tt>' therein.  These files define an import function type called <tt>PluckedString</tt>, which is an implementation of the 
<a href="http://ccrma-www.stanford.edu/CCRMA/Software/clm/compmus/clm-tutorials/pm.html#k-s">Karplus-Strong Plucked String Algorithm</a>.
<p>
<b>Important Note:</b> The Sonic/C++ translator does not validate the C++ header file from which a user-defined class is imported.  Therefore, certain programming errors related to import classes will not be detected by the translator:
<ul>
	<li>header file does not exist</li>
	<li>import class not defined in header file</li>
	<li>wrong number of arguments passed to import class overloaded <tt>operator()</tt></li>
</ul>
Of course, the C++ compiler will catch such errors.  I omitted this kind of error checking from the Sonic/C++ translator because of the complexities of parsing C++ syntax.  This is the only situation where the translator can generate C++ code that does not compile.

<!-- ======================================================================== -->

<hr>
<a name="syntax_var"></a>
<h3>Variable Declarations</h3>
The programmer may delcare <i>local variables</i> within any 
<a href="#syntax_function_user">user-defined function</a> 
and <i>global variables</i> outside a user-defined function.
<p>
All variable declarations begin with the keyword '<tt>var</tt>', followed by one or more comma-delimited variables.  Following the list of comma-delimited variables is the symbol '<tt>:</tt>', then a 
<a href="#syntax_type">data type</a>, 
and finally a semicolon '<tt>;</tt>'.
<p>
A declared variable of numeric or boolean type may optionally have an initializer expression.  If the initializer is omitted, variables of numeric type are implicitly initialized to zero, and variables of boolean type are implicitly initialized to <tt>false</tt>.  A variable of 
<a href="#syntax_function_import">import function type</a> may have an initializer consisting of a comma-delimited list of expressions enclosed in parentheses, comprising the variable's constructor arguments.  A variable of numeric or boolean type may have a single initializer expression either enclosed in parentheses or followed by an equal sign '<tt>=</tt>'.
<p>
All variables (but not function and program arguments) of type <tt>wave</tt> are temporary; any data stored to them will be erased upon the function's return.  Wave variables must never have an initializer.  
<p>
All local variable declarations must occur after the function's opening curly brace '<tt>{</tt>' and before any statements inside the function.  
<p>
There are special rules for 
<a href="#syntax_array">variables of array types</a>. 
<p>
No local variable or user-defined function argument may have the same name as any function or any global variable.  Two local variables and/or function arguments may have the same name so long as they are declared in different functions.
<p>
Here are examples of valid variable declarations.
<blockquote><pre>
program scooby ( outWave: wave )
{
    var freq1 = 440.0, freq2 = freq1 / 2 : real;
    var temp: wave;
    // ... more code here ...
}

var thelma = shaggy(99) : integer;   

function shaggy ( fred: integer ): integer
{
    var sum: integer;   // initialized to zero implicitly
    while ( fred &gt; 0 )
    {
        sum += fred^2;   // add fred squared to sum
        fred -= 1;
    }
    return sum;
}
</pre></blockquote>

<!-- ======================================================================== -->

<hr>
<a name="syntax_statement"></a>
<h3>Statements</h3>
In Sonic, a <i>statement</i> is a unit of executable code.  Statements include constructs like 
<a href="#syntax_statement_simple_assignment">simple assignments</a>, 
<a href="#syntax_statement_wave_assignment">wave assignments</a>,
<a href="#syntax_statement_if">if / else statements</a>,
<a href="#syntax_statement_while">while loops</a>,
<a href="#syntax_statement_for">for loops</a>,
<a href="#syntax_statement_repeat">repeat loops</a>, and
<a href="#syntax_statement_function_call">function calls</a>.
<p>
A statement may be a <i>simple statement</i> which is terminated by a semicolon '<tt>;</tt>', or a <i>compound statement</i> which is a list of zero or more statements enclosed by curly braces '<tt>{}</tt>'.  A compound statement may be used anywhere the 
<a href="#syntax_bnf">Sonic grammar</a> 
calls for a statement.

<!-- ======================================================================== -->

<hr>
<a name="syntax_assignment_operator"></a>
<h4>Assignment Operators</h4>
The following <i>assignment operators</i> are defined in Sonic:
<blockquote>
<b><tt>=    </tt></b>Store the value on the right into the variable on the left.<br>
<b><tt>+=   </tt></b> Add the value on the right to the variable on the left.<br>
<b><tt>-=   </tt></b> Subtract the value on the right from the variable on the left.<br>
<b><tt>*=   </tt></b> Multiply the value on the right into the variable on the left.<br>
<b><tt>/=   </tt></b> Divide the value on the right into the variable on the left.<br>
<b><tt>%=   </tt></b> Store the remainder (integer or real) with the value on the right into the variable on the left.<br>
<b><tt>&lt;&lt;   </tt></b>Append the value on the right to the variable on the left (used only in <a href="#syntax_statement_wave_assignment">wave assignments</a>).<br>
</blockquote>


<!-- ======================================================================== -->

<hr>
<a name="syntax_statement_simple_assignment"></a>
<h4>Simple Assignment Statements</h4>
A <i>simple assignment statement</i> is a statement in which a lone variable appears on the left side of an 
<a href="#syntax_assignment_operator">assignment operator</a>
and an expression appears to the right of the assignment operator, followed by a semicolon '<tt>;</tt>'.  Simple assignments are used to assign the value of a boolean expression to a boolean variable, or to assign a numeric value to an integer or real variable.  There are two kinds of numeric values: integer and real.  Either kind of numeric value may be assigned to either an integer variable or a real variable.  Type conversion of numeric types is implicit in Sonic.
<p>
All of the 
<a href="#syntax_assignment_operator">assignment operators listed in the previous section</a>
are allowed in a simple assignment statement, with the exception of the append operator <tt>&lt;&lt;</tt>, which may be used only in a 
<a href="#syntax_assignment_wave">wave assignment statement</a>.
<p>
Some special rules apply to assignment statements containing 
<a href="#syntax_array">array variables</a>.

<!-- ======================================================================== -->

<hr>
<a name="syntax_statement_wave_assignment"></a>
<h4>Wave Assignment Statements</h4>
<b>Definition.</b>  A <i>wave assignment statement</i> is a statement in which a variable of type <tt>wave</tt>, followed by the string '<tt>[c,i]</tt>' or '<tt>[c,i:<i>expression</i>]</tt>', appears to the left of an 
<a href="#syntax_assignment_operator">assignment operator</a>.  On the right side of the assignment operator is an expression in terms of <tt>c</tt> and <tt>i</tt>.  The symbols <tt>c</tt> and <tt>i</tt> are called <i>placeholders</i>.  They respectively represent the channel index and sample index of a digital audio recording.  These symbols are reserved words, and may appear only in a wave assignment.
<p>
Wave assignment statements are the most important and distinctive feature of the Sonic language.  They allow an entire digital audio operation to be performed, often with a single line of code.  There is no need to explicitly iterate through channels and sample indices in Sonic.  The symbol '<tt>c</tt>' takes on the value of all valid channels, and '<tt>i</tt>' takes on the value of all sample indices.  See the discussion about the 
<a href="#syntax_sample">sample program</a>
earlier in this manual for examples and a conceptual overview.
<p>
<a name="wassign_channel_placeholder"></a>
<b>Channel Placeholder.</b> The placeholder <tt>c</tt> takes on all values from 0 to <tt>m-</tt>1, where <tt>m</tt> is the number of channels, as defined in the section on
<a href="#syntax_constant">built-in constants</a>.
<p>
<a name="wassign_index_placeholder"></a>
<b>Sample Index Placeholder.</b>  The placeholder <tt>i</tt> takes on all values from 0 to <i>N</i><tt>-</tt>1, where <i>N</i> is the number of output samples to be generated.  If the string '<tt>[c,i:<i>expression</i>]</tt>' appears after the wave variable on the left side of the assignment operator, the <tt><i>expression</i></tt> defines the value of <i>N</i>.  This <tt><i>expression</i></tt> is evaluated once before the wave assignment executes.  If <tt><i>expression</i></tt> has non-integer value, it is truncated to the largest integer less than or equal to it.  If the resulting integer is negative or zero, the output generated will be zero samples long.
<p>
If the value of <i>N</i> can be determined from the expression to the right of the assignment operator, i.e. the assigned expression contains other wave expressions having known length, then it is not necessary to provide an explicit number of samples to generate.  This means you can just use the '<tt>[c,i]</tt>' syntax.  In this case, the value of <i>N</i> is automatically the duration of the longest <b>finite</b> input to the right of the assignment operator.  Note that all calls to
<a href="#syntax_function_intrinsic">intrinsic functions</a>,
<a href="#syntax_function_pseudo">pseudo-functions</a>, and 
<a href="#syntax_function_user">user-defined functions</a>
are considered to have infinite duration, so they don't count in the determination of the output's duration.  All finite inputs with duration less than the longest finite input are padded with zero values (silence) at the end.
<p>
If you know how many samples you will generate, and you are not sure whether to include an explicit sample count qualifier, it is recommended that you do include it.  In most cases, the Sonic/C++ translator will issue a translator error when it finds a wave assignment missing a sample count qualifier and whose number of samples cannot be determined.  However, there are a few cases where such a mistake might slip by, resulting in a program that keeps generating output until your hard disk fills up!  So be careful...
<p>
<a name="wassign_rt_placeholder"></a>
<b>Rate and Time Placeholders.</b>  There are two more placeholders to learn about: '<tt>r</tt>' and '<tt>t</tt>', representing sampling rate and current time, respectively.  The symbol '<tt>r</tt>' is a placeholder for the sampling rate being used in a particular Sonic program.  It has integer value, and is expressed in samples per second, or Hz.  By default, its value is 44100 Hz, but the programmer may 
<a href="#syntax_constant">redefine it</a>.  
The programmer may use <tt>r</tt> inside or outside a wave assignment.  It has constant value, unlike the other placeholders mentioned here.  
<p>
A common use of <tt>r</tt> is to convert a time expressed in seconds to a number of samples.  In terms of unit analysis, multiplying time in seconds by <tt>r</tt> samples/second causes the seconds to cancel, resulting in samples.  For example, to generate 7.2 seconds of audio to a wave variable <tt>fred</tt>, use a wave assignment like
<blockquote><pre>
fred[c,i:r*7.2] = somefunc(c,i);
</pre></blockquote>
<p>
The symbol '<tt>t</tt>' represents the time expressed in seconds inside a 
wave assignment.  This symbol has the same value as <tt>i*r</tt>, and is provided for convenience.
<p>
<a name="wassign_operators"></a>
<b>Wave Assignment Operators.</b>  All of the
<a href="#syntax_assignment_operator">assignment operators previously defined</a>
may be used in a wave assignment.  For example, the following wave assignment mixes a half-amplitude version of the wave variable '<tt>mixfile</tt>' into the wave variable '<tt>outfile</tt>':
<blockquote><pre>
outfile[c,i] += 0.5 * mixfile[c,i];
</pre></blockquote>
An operator like <tt>+=</tt> has the same meaning in this context with respect to individual data values that it has in a simple assignment.  However, these <i>mix-assignment operators</i> may be applied only to wave variables on their left that already contain audio data.  An attempt to do otherwise will cause a runtime error.
<p>
<a name="wassign_old_data"></a>
<b>The Old-Data Placeholder </b>'<tt>$</tt>'.  Mix-assignment operators are useful in many cases where the programmer desires to modify the existing audio data in a wave variable.  However, these operators cannot perform every possible modification.  Consider a more general case where the programmer wishes to apply the sine function to the data in a wave variable, and replace the old data in that variable with the result.  One might expect the Sonic code for such a situation to look like this:
<blockquote><pre>
program effect ( sound:wave )
{
    sound[c,i] = sin ( sound[c,i] );    // This doesn't work!
}
</pre></blockquote>
This approach will not work.  The surprising result is that <tt>sound</tt> would end up being a zero-length audio recording.  The reason for this counter-intuitive behavior is that the appearance of the the same wave variable on both sides of <tt>=</tt> always causes the value on the right to be that of the variable during the assignment, not the value before the assignment began.  This is necessary to allow recurrence relations, as was used to produce an echo effect in the <a href="#syntax_sample">sample program</a> earlier in this manual.  In other words, you cannot assign <tt>sound[c,i]</tt> to <tt>sound[c,i]</tt>, because it doesn't have a value yet in that same assignment statement!  Once the assignment statement begins executing, you cannot use the variable <tt>sound</tt> to refer to values it contained before the assignment started.
<p>
To get around this problem, the special placeholder '<tt>$</tt>' is used to represent the old value of <tt><i>x</i>[c,i]</tt>, where <tt><i>x</i></tt> is the name of the variable on the left side of the assignment operator.  So to correct the above code, the program function would be modified to read:
<blockquote><pre>
program effect ( sound:wave )
{
    sound[c,i] = sin($);    // This does work!
}
</pre></blockquote>
<p>
<a name="wassign_append"></a>
<b>The Append Operator</b> <tt>'&lt;&lt;'</tt>.  The assignment operator <tt>&lt;&lt;</tt> appends the wave expression on its right to the wave variable on its left.  Note that the value of the placeholder <tt>i</tt> still starts at zero in this case, and is limited in the same manner as any other wave assignment.  The operator <tt>&lt;&lt;</tt> may appear only in a wave assignment; it is not allowed in a simple assignment.  Here is an example of appending a one-second long 1kHz sinewave to the wave variable '<tt>tones</tt>':
<blockquote><pre>
tones[c,i:r] &lt;&lt; sinewave(1,1000,0);
</pre></blockquote>
<p>
<a name="wassign_vector"></a>
<b>Vector Expressions.</b>  Usually you will code a Sonic wave assignment to make a single expression apply to all channels in the output.  By careful use of the placeholder <tt>c</tt>, you can use a single expression to treat different output channels differently.  For example, if you were making a stereo output file, and you wanted a function <tt>leftfunc(t)</tt> to go to the left channel and a function <tt>rightfunc(t)</tt> to go to the right channel, you could write a line of code like:
<blockquote><pre>
outWave[c,i:5*r] = (1-c)*leftfunc(t) + c*rightfunc(t);
</pre></blockquote>
However, in a wave assignment (and only there), a special syntax is allowed.  The programmer may enclose comma-delimited expressions, one for each channel, inside curly braces <tt>{}</tt>.  The example above could be coded as:
<blockquote><pre>
outWave[c,i:5*r] = { leftfunc(t), rightfunc(t) };
</pre></blockquote>
Any expression of this sort is called a <i>vector expression</i>.  The number of subexpressions within the curly braces of a vector expression must be equal to the number of channels <tt>m</tt>.  Note that you may still use all the placeholders that are usually valid in a wave expression, including <tt>c</tt>.  For example, the vector expression <tt>{c,c}</tt> is equivalent to <tt>{0,1}</tt>.  Vector expressions are more efficient than the equivalent use of multiplying by <tt>(1-c)</tt> and <tt>c</tt> as in the example above.  Furthermore, when there are more than two channels in use, creating a single formula using <tt>c</tt> would be even more inefficient and awkward.

<!-- ======================================================================== -->

<hr>
<a name="syntax_statement_if"></a>
<h4>if / else Statements</h4>
The syntax and semantics of <tt>if / else</tt> statements are almost identical in Sonic and C++.  An important difference is that in Sonic, the argument of <tt>if</tt> must be of type <tt>boolean</tt> (i.e., <tt>integer</tt> values are not allowed).  Just as in C++, the <tt>else</tt> part is optional.  Here are examples of valid <tt>if / else</tt> statements:
<blockquote><pre>
if ( value &gt; maxValue )
    maxValue = value;
else if ( -value &gt; maxValue )
    maxValue = -value;

if ( x&lt;17 &amp; y&lt;40 )    // note that '&amp;' is boolean AND, not bitwise
{
    x = SomeFunc(x);
    y += 3;
}
</pre></blockquote>

<!-- ======================================================================== -->

<hr>
<a name="syntax_statement_while"></a>
<h4>while Statements</h4>
The <tt>while</tt> statement in Sonic is much like its counterpart in C++.  As with the <tt>if</tt> construct, the argument of <tt>while</tt> must have <tt>boolean</tt> type.  The following function shows how to implement a factorial using a while loop.
<blockquote><pre>
function factorial ( num: integer ): integer
{
    var product=1: integer;

    while ( num &gt; 0 )
    {
        product *= num;
        num -= 1;
    }

    return product;
}
</pre></blockquote>

<!-- ======================================================================== -->

<hr>
<a name="syntax_statement_for"></a>
<h4>for Statements</h4>
The <tt>for</tt> statement in Sonic is similar to the one in C++.  It uses the following syntax:
<blockquote><pre>
for ( <i>initializer</i>; <i>condition</i>; <i>update</i> )
    <i>statement</i>
</pre></blockquote>
The <tt><i>initializer</i></tt> and <tt><i>update</i></tt> must be
assignment statements, meaning they may be either 
<a href="#syntax_statement_simple_assignment">simple assignment statements</a> or
<a href="#syntax_statement_wave_assignment">wave assignment statements</a>.  The <tt><i>condition</i></tt> must be a boolean expression.  The <tt>for</tt> construct is simply a shorthand notation for a 
<a href="#syntax_statement_while">while loop</a>, as the above code is equivalent to:
<blockquote><pre>
<i>initializer</i>;
while ( <i>condition</i> )
{
    <i>statement</i>;
    <i>update</i>;
}
</pre></blockquote>
Here is an example of using <tt>for</tt> loops to initialize a two-dimensional array:
<blockquote><pre>
function something()
{
    var z: real[5,3];
    var row, col: integer;
    for ( row=0; row&lt;5; row += 1 )
        for ( col=0; col&lt;5; col += 1 )
            z[row,col] = row + noise(col);
}
</pre></blockquote>

<!-- ======================================================================== -->

<hr>
<a name="syntax_statement_repeat"></a>
<h4>repeat Statements</h4>
Often a programmer wishes to repeat a block of code a specific number of times.  In cases like this, typically a loop is coded in which a variable is incremented until it reaches a certain value.  However, in many of these cases, the variable is not used for any purpose other than as a loop counter.
<p>
The <tt>repeat</tt> statement is ideal for situations like this.  The syntax of a <tt>repeat</tt> statement is as follows:
<blockquote><pre>
repeat ( <i>numeric_expression</i> )
    <i>statement</i>
</pre></blockquote>
The <tt><i>numeric_expression</i></tt> is evaluated only once.  If it has a non-integer value, it is truncated to the closest integer smaller than it.  If the resulting value is less than or equal to zero, the <tt><i>statement</i></tt> is not executed.  Otherwise, the statement is executed the number of times indicated by the <tt><i>numeric_expression</i></tt>.
<p>
The <tt><i>numeric_expression</i></tt> may be any expression of type <tt>real</tt> or <tt>integer</tt>, and the operation of the <tt>repeat</tt> construct has no side effects on its argument.  Because the argument expression is evaluated only once, any effects that the <tt><i>statement</i></tt> body may have on variables in the <tt>repeat</tt> argument will not alter the number of iterations.
<p>
The following example function creates an output sound that contains the input sound repeated the specified number of times.
<blockquote><pre>
function OverAndOver ( inWave:wave, outWave:wave, numTimes:integer )
{
    outWave[c,i:0] = 0;    // make the output sound be zero samples long

    repeat ( numTimes )
    {
        outWave[c,i] &lt;&lt; inWave[c,i];   // append inWave to outWave
    }
}
</pre></blockquote>

<!-- ======================================================================== -->

<hr>
<a name="syntax_statement_return"></a>
<h4>return Statements</h4>
The <tt>return</tt> statement is identical to its counterpart in C++.  Inside a 
<a href="#syntax_function_user">user-defined function</a>
that returns a value, it must have an argument that can be converted to the same type as the function's return type.  In functions without a return value, there must be no argument.  Here are examples of valid uses of the <tt>return</tt> statement:
<blockquote><pre>
function hypotenuse ( x:real, y:real ): real
{
    return sqrt ( x*x + y*y );
}

function AppendMaybe ( outWave:wave, inWave:wave, doit:boolean )
{
    if ( !doit )
        return;

    repeat ( 5 )
        outWave[c,i] &lt;&lt; inWave[c,i];
}
</pre></blockquote>

<!-- ======================================================================== -->

<hr>
<a name="syntax_statement_function_call"></a>
<h4>Function Calls</h4>
In addition to appearing within an expression on the right side of an 
<a href="#syntax_assignment_operator">assignment operator</a>, 
a function call may appear by itself as a statement.  As in C++, such a function may or may not return a value.  If it does return a value, the returned value is ignored and discarded.  Generally, a function call statement is useful only when it has some side effect, which almost always means some digital audio operation on one of its arguments of type <tt>wave</tt>.  Here is an example of a Sonic program that uses function call statements in this manner.

<blockquote><pre>
program charro ( inWave:wave, outWave:wave )
{
    var temp: wave;
    trill ( inWave, temp, 3 );     // make 'temp' be 'inWave' repeated 3 times
    trill ( temp, outWave, 2 );    // make 'outWave' be 'inWave' repeated 6 times
}

function trill ( x:wave, y:wave, k:integer )
{
    y[c,i:0] = 0;    // make 'y' be zero-length
    repeat ( k )
        y[c,i] &lt;&lt; x[c,i];
}
</pre></blockquote>

Note that function arguments of type <tt>wave</tt> (unlike all other data types) are passed by reference, not value.  This means that <tt>wave</tt> arguments may be modified by the called function and the modification will persist in the calling code.  It also means that only a <tt>wave</tt> variable may be passed as a <tt>wave</tt> argument, not a general expression.

<!-- ======================================================================== -->

<hr>
<a name="syntax_expression"></a>
<h3>Expressions and Operators</h3>
Expressions and operators in Sonic are similar to those in C++, but with some significant differences.  Sonic has fewer operators than C++, and some of the operators have different meanings.  Here is a list of the operators in Sonic and what they mean.  They are listed in order from lowest precedence to highest precedence.  For a formal description of Sonic syntax, see the 
<a href="#syntax_bnf">Extended BNF</a>
section.
<blockquote>
<tt><b>|</b></tt><br>
boolean OR (not bitwise)
<p>
<tt><b>&amp;</b></tt><br>
boolean AND (not bitwise)
<p>
<tt><b>== &lt; &lt;= &gt; &gt;= != &lt;&gt;</b></tt><br>
comparison operators.  The operators <tt>!=</tt> and <tt>&lt;&gt;</tt></li> both mean &quot;not equal&quot;.
<p>
<tt><b>+ -</b></tt><br>
add, subtract two numbers.
<p>
<tt><b>* / %</b></tt><br>
multiply, divide, modulus.  Unlike in C++, the <tt>%</tt> operator allows operands to be integer or real.
<p>
<tt><b>^</b></tt><br>
numeric exponentiation.  <tt><i>x</i>^<i>y</i></tt> means <tt><i>x</i></tt> raised to the <tt><i>y</i></tt> power.
<p>
<tt><b>! -</b></tt><br>
the unary operators boolean NOT and negative.
<p>
<tt><b>. []</b></tt><br>
field selector and wave expression indexing.  The left side of '<tt>.</tt>' must be a variable of type <tt>wave</tt>.  The right side must be one of the following:
<blockquote>
<p>
<tt><b>n</b></tt> = The number of samples in the wave.<br>
<tt><b>r</b></tt> = Same as global constant <tt>r</tt>.<br>
<tt><b>m</b></tt> = Same as global constant <tt>m</tt>.<br>
<tt><b>max</b></tt> = The maximum absolute amplitude of data in the wave.<br>
</blockquote>
<p>
<tt><b>()</b></tt><br>
Parentheses used to override operator precedence.
</blockquote>

<!-- ======================================================================== -->

<hr>
<a name="syntax_comment"></a>
<h3>Comments</h3>
Just as in C++, Sonic provides two different ways to include comments in source code.  The first method is to use a double slash <tt>//</tt>, which causes the Sonic translator to ignore the slashes and all subsequent characters on the same line of text.  Here is an example:
<blockquote><pre>
outWave[c,i] = inWave[c,i];   // copy the input to the output
</pre></blockquote>
The second form of comment is bounded by the string <tt>/*</tt> and the string <tt>*/</tt>.  Such a comment may span more than one line.  When this form of comment is used, all characters including and between the two strings <tt>/*</tt> and <tt>*/</tt> are ignored by the Sonic translator.  Note that after <tt>/*</tt> is found, the very first occurrence of <tt>*/</tt> terminates the comment, regardless of whether another <tt>/*</tt> string is found after the beginning <tt>/*</tt>.  In other words, comments of this form are not nestable.  Here is an example of this kind of comment:
<blockquote><pre>
/*
     The following program switches the channels in the input file
     to produce the output file.  In other words, the left channel
     in the input becomes the right channel in the output, and vice versa.
*/

m = 2;   /* explicitly state that this is stereo audio */

program swap ( input:wave, output:wave )
{
    output[c,i] = input[1-c,i];
}
</pre></blockquote>

<!-- ======================================================================== -->

<hr>
<a name="syntax_bnf"></a>
<h3>Extended Backus-Naur Form Syntax of Sonic</h3>
The following notation formally defines the grammar of the Sonic language using Extended Backus-Naur Form.  In this notation, syntactic constructs are defined by names like <tt>statement</tt>.  They appear on the left side of a '<tt>::=</tt>', and the definition of each such symbol appears to the right of the '<tt>::=</tt>'.
<p>
Textual symbols that appear literally in the source code are enclosed within double-quotes, e.g., <tt>&quot;integer&quot;</tt>.
<p>
Items separated by the '<tt>|</tt>' symbol are mutually exclusive alternatives.  For example, a <tt>parm_name</tt> is allowed to be either the literal string <tt>&quot;r&quot;</tt> or the literal string <tt>&quot;m&quot;</tt>.  
<p>
Items enclosed inside square brackets <tt>[]</tt> are optional; they may appear either zero or one times in the place indicated.
<p>
Items enclosed inside curly braces <tt>{}</tt> may appear zero or more times.
<p>
Items in <tt><i>italics</i></tt> are English descriptions of a lexical construct.  I chose such descriptions when I felt they would be best understood that way.
<blockquote><pre>
program ::=  {global} program_body {global}
global ::= function_body | parm_override | import_decl | var_decl
import_decl ::=  &quot;import&quot; import_name { &quot;,&quot; import_name } &quot;from&quot; string_constant &quot;;&quot;
import_name ::= name

parm_override ::=  parm_name &quot;=&quot; integer_const &quot;;&quot; | 
                   &quot;interpolate&quot; &quot;=&quot; boolean_const &quot;;&quot;

parm_name ::=  &quot;r&quot; | &quot;m&quot;

program_body ::=  &quot;program&quot; name &quot;(&quot; func_args &quot;)&quot;
                  &quot;{&quot; {var_decl} {statement} &quot;}&quot;

statement ::=  [function_call] &quot;;&quot; | assignment &quot;;&quot; | 
               if_body | while_body | repeat_body | for_body
               &quot;return&quot; [b0] &quot;;&quot; |
               &quot;{&quot; {statement} &quot;}&quot;

var_decl ::= &quot;var&quot; var_spec { &quot;,&quot; var_spec } &quot;:&quot; type &quot;;&quot;
var_spec ::= name [ var_init ]

var_init ::= &quot;=&quot; b0 | &quot;(&quot; [ b0 { &quot;,&quot; b0 } ] &quot;)&quot;

type ::= basic_type | &quot;wave&quot; | import_name | array_type
array_type ::= basic_type &quot;[&quot; integer_constant { &quot;,&quot; integer_constant } &quot;]&quot;
basic_type ::=  &quot;real&quot; | &quot;integer&quot; | &quot;boolean&quot; 

function_call ::=  name &quot;(&quot; [ expr { , expr } ] &quot;)&quot;

function_body ::=  &quot;function&quot; name &quot;(&quot; func_args &quot;)&quot; [ &quot;:&quot; type ]
                    &quot;{&quot; {var_decl} {statement} &quot;}&quot;

func_args ::=  [ arg { &quot;,&quot; arg } ]
arg ::=  name &quot;:&quot; type [&quot;&amp;&quot;]
assignment ::=  lvalue assign_op expr
lvalue ::=  name [ &quot;[&quot; &quot;c&quot; &quot;,&quot; &quot;i&quot; [ &quot;:&quot; term ] &quot;]&quot; ] | name &quot;[&quot; term { &quot;,&quot; term } &quot;]&quot;
assign_op ::=  &quot;=&quot; | &quot;&lt;&lt;&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; | &quot;%=&quot; 
expr ::=  b0 | &quot;{&quot; b0 {&quot;,&quot; b0} &quot;}&quot;
b0 ::=  b1 { &quot;|&quot; b1 }
b1 ::=  b2 { &quot;&amp;&quot; b2 }
b2 ::=  term [ relop term ]
relop ::=  &quot;==&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; | &quot;!=&quot; | &quot;&lt;&gt;&quot;
term ::=  t1 { op1 t1 }
op1 ::=  &quot;+&quot; | &quot;-&quot;
t1 ::=  t2 { op2 t2 }
op2 ::=  &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
t2 ::=  t3 [ &quot;^&quot; t2 ]
t3 ::=  constant | var_term | function_call | &quot;(&quot; b0 &quot;)&quot; | &quot;!&quot; t3 | &quot;-&quot; t3 | &quot;$&quot;
var_term ::=  name [var_qualifier]
var_qualifier ::= &quot;.&quot; wave_field | &quot;[&quot; term { &quot;,&quot; term } &quot;]&quot; 
wave_field ::= &quot;n&quot; | &quot;r&quot; | &quot;m&quot; | &quot;max&quot;
constant ::=  numeric_constant | string_constant | builtin
builtin ::= &quot;pi&quot; | &quot;e&quot; | &quot;i&quot; | &quot;c&quot; | &quot;n&quot; | &quot;t&quot; | parm_name | boolean_const
boolean_const ::= &quot;true&quot; | &quot;false&quot;
if_body ::=  &quot;if&quot; &quot;(&quot; b0 &quot;)&quot; statement [ &quot;else&quot; statement ]
while_body ::=  &quot;while&quot; &quot;(&quot; b0 &quot;)&quot; statement
for_body ::=  &quot;for&quot; &quot;(&quot; assignment &quot;;&quot; b0 &quot;;&quot; assignment &quot;)&quot;  statement
repeat_body ::= &quot;repeat&quot; &quot;(&quot; term &quot;)&quot; statement

numeric_constant ::= integer_constant | real_constant

integer_constant ::= <i>a decimal integer number, e.g. 123</i>

real_constant ::= <i>a decimal real number expressed in standard (123.4) 
                  or scientific (1.234e+2) notation</i>

string_constant ::= <i>zero or more ASCII characters inside double quotes</i>
name ::= alpha{alnum}
alpha ::= <i>any alphabetic character &quot;a&quot;-&quot;z&quot;, &quot;A&quot;-&quot;Z&quot;, or underscore &quot;_&quot;</i>
alnum ::= alpha | &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;
</pre></blockquote>

<!--
	<p>
	<hr>
	<a name="sound_format"></a>
	<h2>Audio File Formats</h2>
	<i>to be completed soon...</i>
-->

<!-- ======================================================================== -->

<p>
<hr>
<a name="translator"></a>
<h2>How to Use the Sonic/C++ Translator</h2>
The Sonic/C++ translator is a command-line utility that accepts one or more command-line parameters.  Each command-line parameter is a Sonic source filename.  For example, if you have written a Sonic program saved to the file '<tt>barney.s</tt>' and it uses some functions contained in another file '<tt>wilma.s</tt>', use the following command to translate it into C++ source code:
<blockquote><pre>
sonic barney.s wilma.s
</pre></blockquote>
The output filename is <b>not</b> derived from any of the input filenames.  Instead, it is determined by the name following the program function.  For example, if the program function looks like
<blockquote><pre>
program betty ( inWave:wave, outWave:wave )
{
    ...
}
</pre></blockquote>
then the output filename will be '<tt>betty.cpp</tt>'.  Although there may be any number of input source files, there must be exactly one program function amongst all of them.  The source files may appear in any order without incurring errors, regardless of which functions call which others across source files.
<p>
Of course, after you translate Sonic into C++, you will need to compile and link it with the C++ compiler of your choice.  To do this without getting compiler and linker errors, you will need to get a copy of the Sonic runtime library.  Place the following header files from the runtime library in your C++ compiler's include path:
<blockquote><pre>
sonic.h
copystr.h
ddc.h
riff.h
fourier.h
</pre></blockquote>
In addition to the source file generated by the Sonic/C++ translator, include the following source files in the build of your project:
<blockquote><pre>
sonic.cpp
copystr.cpp
riff.cpp
fourierd.cpp
fftmisc.cpp
</pre></blockquote>
<p>
I have tried to document all of the features of Sonic in this manual accurately and lucidly.  However, there certainly are things that can be confusing.  One suggestion I have for times of confusion is to examine the C++ code generated by the translator.  I have tried to make the C++ code produced by the Sonic translator as readable as possible.  All output is neatly formatted, and constructs which generate complex code such as wave assignments are commented with the original Sonic code next to the C++ code.  In many cases, the programmer can experiment by trial and error, reading the code produced by the translator, to understand the Sonic language better.
<p>
Good luck, and happy acoustic hacking!  If you have any problems, questions, comments, or suggestions, feel free to contact me, Don Cross, by email using the address at the beginning of this manual.  Please let me know of any bugs in the translator or runtime library, or if you find parts of this manual incorrect or confusing.  I would also like to hear of any interesting results you have obtained using Sonic.  Feel free to send programs you have written my way, especially if you would like to contribute sample programs for publication.
</body>
</html>
